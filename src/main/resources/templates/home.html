<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.springframework.org/schema/mvc">
<head>
    <meta charset="UTF-8">
    <title>Dynamic SSE Dropbox</title>
    <script src="/sjcl.js" th:src="@{/sjcl.js}"></script>
</head>
<body>
    <p>
        <input id="password" type="password" placeholder="Password" oninput="setPassword(event)">
    </p>
    <div>
        <form id="upload">
            <p>
                <input id="fileInput" type="file">
            </p>
            <p>
                <button onclick="readWords(event)">Upload</button>
            </p>
        </form>
    </div>
    <div>
        <form id="search">
            <p>
                <input id="query" type="text" placeholder="Search Query">
            </p>
            <p>
                <button onclick="doSearch(event)">Search</button>
            </p>
        </form>
    </div>
    <div>
        <ul id="results">

        </ul>
    </div>


    <script>
        //Generates a new key
        var newKey = function() {
            return sjcl.random.randomWords(8);
        };

        var password = "";
        var keys = {};
        keys['esk'] = newKey();
        var prf = new sjcl.cipher.aes(keys['esk']);
        var iv = newKey(); //will make dynamic later

        //Sets the user password and generates esk key
        var setPassword = function(event) {
            password = event.target.value;
            keys['esk'] = sjcl.misc.pbkdf2(password, "", 50000);
            prf = new sjcl.cipher.aes(keys['esk']);
        };

        //Generates word set from file
        var readWords = function(event) {
            event.preventDefault();
            var fileInput = document.getElementById("fileInput");
            var file = fileInput.files[0];


            var fileReader = new FileReader();
            fileReader.onloadend = function() {
                var wordSet = {};
                var text = fileReader.result;
                var plaintext = sjcl.codec.utf8String.toBits(text);
                var ciphertext = sjcl.mode.gcm.encrypt(prf, plaintext, iv);
                ciphertext = base64encode(ciphertext);
                var id = file.name;
                id = sjcl.codec.utf8String.toBits(id);
                id = sjcl.hash.sha256.hash(id);
                id = sjcl.codec.base32.fromBits(id);
                console.log(id);
                //var id = base64encode(sjcl.hash.sha256(sjcl.codec.utf8String.toBits(fileInput.value)));
                if(file.type === 'text/plain') {
                    text = text.trim();
                    text.split(/[\s]+/).forEach(function(element) {
                        wordSet[element] = true;
                        //base64encode(sjcl.mode.gcm.encrypt(prf, sjcl.codec.utf8String.toBits(element), iv))
                    });
                }
                else {
                    text = file.name;
                    text = text.substring(0, text.lastIndexOf('.'));
                    text = text.split(/[\s]+/).forEach(function(element) {
                        wordSet[element] = true;
                    });
                    console.log(wordSet);
                }
                uploadFile(ciphertext, id);
                update(Object.keys(wordSet), id, 0);
            };

            fileReader.readAsText(file);
        };

        var uploadFile = function(ciphertext, id) {
            console.log(id);
            var formdata = new FormData();
            formdata.append('file', new File([ciphertext], id, {type:'text/plain'}));
            var req = new XMLHttpRequest();
            req.open("POST", "/api/upload");
            req.send(formdata);
        };

        //Performs search on form input
        var doSearch = function() {
            event.preventDefault();
            var query = document.getElementById("query").value;
            search(query);
        };

        //Searches keyword
        var search = function(w) {
            var tokens = {};
            var k = Object.keys(keys);
            for(var i = 0; i < k.length; i++) {
                if(k[i] !== 'esk') {
                    tokens[k[i]] = token(k[i], w);
                    console.log(k[i]);
                    console.log(tokens[i]);
                }
            }

            var req = new XMLHttpRequest();

            req.onreadystatechange = function(e) {
                if(req.readyState === 4 && req.status === 200) {
                    console.log(req.response);
                }
            };

            req.open("POST", "/api/search", false);
            req.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
            req.send(JSON.stringify(tokens));
        };

        //Updates index
        var update = function(v, id, op) {
            v.forEach(function(w) {
                var req = new XMLHttpRequest();

                req.onreadystatechange = function(e) {
                    if(req.readyState === 4 && req.status === 200) {
                        if (req.response === 'true') {
                            rebuild(w, id, op);
                        }
                        else {
                            insert(w, id, op);
                        }
                    }
                };

                req.open("GET", "/api/needsRebuild", false);
                req.send();
            });
        };

        var insert = function(w, id, op) {
            keys[0] = newKey();
            var entry = encodeEntry(0, [w, id, op, 0]);
            var req = new XMLHttpRequest();

            req.onreadystatechange = function(e) {
                if(req.readyState === 4 && req.status === 200) {
                }
            };

            req.open("POST", "/api/update", false);
            req.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
            req.send(JSON.stringify(entry));
        };

        var rebuild = function(w, id, op) {
            var T = fetchTable();
            var l = fetchLevel();
            var lev = simpleRebuild(fetchTable(), fetchLevel(), w, id, op);

            var req = new XMLHttpRequest();

            req.onreadystatechange = function(e) {
                if(req.readyState === 4 && req.status === 200) {
                }
            };

            req.open("POST", "/api/rebuild", false);
            req.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
            req.send(JSON.stringify(lev));
        };

        //Returns whether table must be rebuilt or not
        var needsRebuild = function() {
            var req = new XMLHttpRequest();

            req.onreadystatechange = function(e) {
                if(req.readyState === 4 && req.status === 200) {
                    return req.response === 'true';
                }
            };

            req.open("GET", "/api/needsRebuild", false);
            req.send();
            return req.onreadystatechange();
        };

        //Fetches table up to first empty level from server
        var fetchTable = function() {
            var req = new XMLHttpRequest();

            req.onreadystatechange = function(e) {
                if(req.readyState === 4 && req.status === 200) {
                    return JSON.parse(req.response);
                }
            };

            req.open("GET", "/api/table", false);
            req.send();
            return req.onreadystatechange();
        };

        //Fetches first empty level from server
        var fetchLevel = function() {
            var req = new XMLHttpRequest();

            req.onreadystatechange = function(e) {
                if(req.readyState === 4 && req.status === 200) {
                    return req.response;
                }
            };

            req.open("GET", "/api/level", false);
            req.send();
            return req.onreadystatechange();
        };

        //Rebuilds first l-1 levels of table
        var simpleRebuild = function(T, l, w, id, op) {
            var B = [];
            B[0] = [w, id, op, 0];
            for(var key in Object.keys(T)) {
               B.push(decrypt(T[key]['c2']));
            }
            B.sort(lexSort);
            B = reCnt(B);
            keys[l] = newKey();
            var lev = [];
            B.forEach(function(tuple) {
                lev.push(encodeEntry(l, tuple));
            });
            lev.sort(hkeySort);
            return lev;
        };

        //Sorts buffer by w > id > op
        var lexSort = function(a, b) {
            if(a[0] === b[0]) {
                if(a[1] === b[1]) {
                    if(a[2] === b[2]) {
                        return 0;
                    }
                    else return (a[2] < b[2]) ? -1 : 1;
                }
                else return (a[1] < b[1]) ? -1 : 1;
            }
            else return (a[0] < b[0]) ? -1 : 1;
        };

        //Sorts level by hkey
        var hkeySort = function(a, b) {
            if(a[0] === b[0]) return 0;
            else return (a[0] < b[0]) ? -1 : 1;
        };

        //Updates cnt values in sorted buffer
        var reCnt = function(B) {
            var prevW = "";
            var prevOp = -1;
            var prevCnt = -1;
            for(var i = 0; i < B.length; i++) {
                if(B[i][0] === prevW) {
                    if((B[i][1] === B[i-1][1]) && (B[i][2] + prevOp === 1)) {
                        prevOp = -1;
                        prevCnt--;
                        if(prevCnt === -1) prevW = "";
                        B[i-1] = B[i] = null;
                    }
                    else {
                        B[i][3] = ++prevCnt;
                        prevOp = B[i][2];
                    }
                }
                else {
                    B[i][3] = prevCnt = 0;
                    prevW = B[i][0];
                    prevOp = B[i][2];
                }
            }
            return B;
        };

        //Decrypts table entry to return (w, id, op, cnt)
        var decrypt = function(c2) {
            return JSON.parse(sjcl.codec.utf8String.fromBits(sjcl.mode.gcm.decrypt(prf, base64decode(c2), iv)));
        };

        var token = function(l, w) {
            var levelPrf = new sjcl.cipher.aes(keys[l]);
            var tkn = sjcl.mode.gcm.encrypt(levelPrf, sjcl.hash.sha256.hash(w), iv);
            console.log(base64encode(tkn));
            return base64encode(tkn);
        };

        //Encodes a tuple (w, id, op, cnt) and returns a tuple (hkey, c1, c2)
        var encodeEntry = function(l, tuple) {
            var tkn = token(l, tuple[0]);
            var hmac = new sjcl.misc.hmac(tkn);
            var hmacBits = bite([0, tuple[2], tuple[3]]);
            var hkey = hmac.encrypt(hmacBits);
            hkey = base64encode(hkey);
            console.log(hkey);
            var c1Bits = bite([1, tuple[2], tuple[3]]);
            var c1 = hmac.encrypt(c1Bits);
            c1 = base64encode(bite(tuple[1] ^ sjcl.bitArray.extract(c1, 0, c1.length)));
            var c2 = sjcl.mode.gcm.encrypt(prf, bite(tuple), iv);
            c2 = base64encode(c2);
            return [hkey, c1, c2];
        };

        //Converts an item to a bitArray
        var bite = function(item) {
            console.log(JSON.stringify(item));
            return sjcl.codec.utf8String.toBits(JSON.stringify(item));
        };

        var base64encode = function(b) {
            return sjcl.codec.base64.fromBits(b);
        };

        var base64decode = function(b) {
            return sjcl.codec.base64.toBits(b);
        };

    </script>
</body>
</html>